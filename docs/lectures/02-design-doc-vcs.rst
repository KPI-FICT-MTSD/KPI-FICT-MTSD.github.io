========================================
Дизайн-документ. Системи контролю версій
========================================

Практика і спілкування з різними інженерами показує, що у нас в Україні дуже
люблять підхід “тяп-ляп і в продакшн”. Це звісно весело, дух стартапу і все
таке. Але як ви думаєте, скільки зазвичай такий проект проживе? Наскільки
просто його підтримувати? А після звільнення автора оцього самого ключового
модуля, який тяп-ляпався?

Якщо проект/компонент, що ми розробляємо складний, то гарно було б поміркувати
про те, як його реалізовувати, яку архітектуру застосувати, тощо. Оцей етап
проектування — важливий. Ви ж не будете наобум будувати ракету, а там — якось
воно вийде? Спершу варто задуматися і спробувати продумати основну архітектуру.
А щоб це все не забулося — записати

І отаким от артефактом продумування архітектури, відкидання одних варіантів і
прийняття інших, є дизайн-документ. Розробляють цей дизайн-документ для того,
щоб у першу чергу виявити проблеми в архітектурі. Часто ж буває, що поки ідея у
вас в голові — все весело-прикольно і круто, але як тільки ви починаєте її
комусь розповідати і описувати — воно звучить не так круто?

Також перед початком розробки важливо переконатися, що усі учасники однаково
розуміють архітектуру проекту. Так, звучить дико, але якщо не буде спільного
бачення, то розробка буде болючою, особливо на етапі, коли люди з різним
розумінням чи баченням проекту намагатимуться зістикувати свої зусилля.

Звісно, що при продумуванні архітектури варто продумати і крайові випадки які
можуть сплисти: низька швидкодія, підвищені вимоги до безпеки, необхідність
враховувати третій сервіс —  усі ці моменти, чим раніше про них згадали, тим
менше болю вони вам принесуть в майбутньому. Дуже важко вставити в робочий
проект фічу, яка не вписується в архітектуру. Дуже складно у великий проект,
який робився з повним забиванням на безпеку, коректно додати нормальну
авторизацію, автентикацію, розмежування прав доступу, шифрування і багато
іншого — це все треба прораховувати заздалегідь

Також цей документ можна шарити — таким чином не буде однієї людини, яка
шарить, як проект працює, і при відсутності якої розробка стане. Також,
розшаривши цей документ в команді у людей буде краще розуміння, що вони роблять
і для чого; нова людина зможе ознайомитися з проектом та швидше в нього
влитися.

Часто буває так, що ви робите фічу, і вам приходить в голову думка: “блін, чому
я роблю так складно, можна ж зробити в 100 разів простіше”. Ви робите простіше
і думаєте: ну і чому я вирішив(-ла) робити перший варіант?. І тут в самому
кінці ви розумієте, що є одна фіча, яка в простий варіант не вписується зовсім.
Але при цьому без цієї фічі — ну зовсім ніяк. Наша пам’ять — на жаль,
неідеальна, тому ми можемо забувати ті чи інші причини, чому ми зробили так, а
не інакше. У мене була історія один-в-один з описаним, коли треба було
інтегруватися з платіжним провайдером. Спершу все продумав, але не занотував,
почав робити. Піймав себе на думці, що виходить збіса складно, відкотив зміни і
почав робити простий варіант. А потім згадав за важливу фічу про те, що має
бути можливість скасувати платіж протягом 30с після його здійснення. І от через
цю фічу простий варіант не підходив зовсім. Весь простий варіант, який був
дописаний до кінця, був викинутий і я знову почав спочатку реалізовувати
складний, з якого почав. Так я потратив достатньо багато часу на це все діло.

З тих же причин неідеальності пам’яті гарно мати взагалі підсумок усього
проектування, яким і слугує дизайн-документ.

Взагалі, чіткої структури і строгого гайду по написанню дизайн-документа немає,
і пишуть його у тому вигляді, в якому це найбільш доречно для того чи іншого
проекту.

Проте, зі свого досвіду, інженери із Google виявили, що є секції, які присутні
практично у всіх таких документах, які вони пишуть.

Context and scope — коротко про те, що це за проект, для чого, в якій
інфраструктурі він буде працювати. Це не список бізнес-вимог, тож робимо це
діло коротким

Goals and non-goals — список задач, які наш проект вирішує та список того, що
out-of-scope в нашому проекті. Non-goals — це не тупо заперечення вимог, не
перерахованих в goals. Приклад: автентикація та авторизація не є задачами
проекту, тому що 1) проект навчальний, 2) він запускатиметься в захищеному
периметрі, 3) ще щось.

The actual design — один з найважливіших розділів. Тут описуємо ті рішення, які
ми прийняли та компроміси, на які ідемо. При цьому рішення мають бути розписані
детально, але при цьому не спускатися до рівня коду. Класно в цьому розділі
намалювати схему вашої системи. Якщо ваша система має API для взаємодії з нею —
цей розділ — ідеальне місце для опису цього API. Код чи псевдокод зазвичай у
таких документах не пишуть, але якщо є необхідність описати якийсь специфічний
алгоритм, то це допускається.

Alternatives considered — у цьому розділі ви описуєте, які ще варіанти
розглядали, і чому від них відмовилися на користь того, що описано в actual
design. Це якраз те саме місце, яке не дасть вам забути, чому ви відмовилися
від простого варіанту.

Часто при написанні курсових чи дипломних робіт у нас виникало запитання: а на
скільки сторінок писати? Так от, дизайн-док — це не кусач. Немає якогось
еталонного “тут має бути X сторінок”. Документ повинен бути достатньо
деталізованим, щоб читач зміг зрозуміти проблему та її рішення, але при цьому
не має бути надто довгим — пам’ятайте, інженери — зайняті люди і їхній час
недешевий, тому лити воду в такий документ — це витрачати їхній дорогоцінний
час. Ідеальний дизайн документ — не той, в який нічого додати, а той, з якого
не можна нічого викинути ;-)


https://www.industrialempathy.com/posts/design-docs-at-google/


Давайте уявімо, що ми розробники бородатих років. Нас задовбало, що у нас немає
стандартного способу роботи над проектом, щоб ми могли в нього вносити зміни та
повертатися до попередніх версій, якщо наші зміни не дуже. А також було б
чудово мати можливість зберігати проект не тільки на своєму комп’ютері, а десь
на сервері і щоб ми могли з цього серверу отримувати нові зміни у цей проект.

Оскільки мова про те, щоб ми могли керувати різними версіями проектів, то
давайте назвемо нашу систему, що ці проблеми вирішуватиме, Version Control
System.

Давайте спробуємо написати для неї дизайн-документ.


У розділі ``Context`` напишемо пару речень про те, що це за проєкт, кому і для чого він потрібен:


    Розробляємо систему для роботи над проектами в сфері розробки. Ця система
    повинна дозволяти зручно працювати з історією нашого проекту, відкочуватися
    до попередніх версій, фіксувати ті чи інші логічно завершені етапи роботи.
    Користувачі нашого проекту — розробники, які працюють за своїми робочими
    станціями

В ``Goals`` описуємо задачі, які наш проєкт вирішуватиме:

    - відкатування до попередньої версії проєкту
    - відслідковування історії змін
    - фіксація завершених етапів роботи
    - графік активності над проєктом (скільки задач/змін було виконано в той чи
      інший день)

В ``Non-goals`` пишемо те, що подібні проєкти зазвичай вирішують, але наш з
тієї чи іншої причини не робитиме:

    - Авторизація (проєкт для локальних однокористувацьких робочих станцій)
    - Приховані проєкти (немає сенсу, бо все буде доступне на файловій системі
      робочої станції)

Описуємо архітектуру нашого проєету у розділі ``Subsystems``:

    2 підсистеми: інтерфейс командного рядка (CLI), який викликає ті чи інші
    функції підсистеми збереження даних.

    CLI надає наступний інтерфейс:

    - save (фіксує поточний стан проекту)
    - history (подивитися історію попередніх збережень)
    - load (завантажити конкретну версію проєкту)
    - goback (завантажити попередню версію проєкту)
    - stats (намалювати псевдографікою активність)

    Зберігання даних

    - робимо в проєкті приховану директорію .history
    - в цій директорії у нас будуть zip архіви з версіями проєкту іменовані
      наступним чином: 0001-some-message.zip, 0002-some-message.zip, тощо
    - при команді save ми створюємо з файлів проєкту новий архів і
      інкрементуємо його порядковий номер версії
    - при команді load/goback ми розпаковуємо вміст архіву відповідної версії в
      директорю проєкту
    - команда history показує нам список архівів у папці .history та дату їх
      створення
    - stats рахує кількість архівів за той чи інший день

І насамкінець в ``Alternatives Considered`` зазначаємо інші архітектури/підходи
які розглядали, але які нам не підійшли:

    збереження даних у вигляді діфу від попередньої версії не підходить, бо вносить
    додаткові труднощі при переключеннях між різними версіями проєкту

Вітаю, ми задизайнили свою систему контролю версій! Тепер залишилося її
реалізувати і піарити)

Власне, задачі, які вирішують системи контролю версій — це можливість бекапу
проекту, спільна робота над проектом, і, власне, керування версіями: перейти до
попередньої версії, зафіксувати поточний стан проекту як нову версію, відкотити
зміни, тощо.

Взагалі, існує чимало вже готових інструментів для цього. Те, що задизайнили ми
найбільше схоже на (svn/git/mercurial). Але останнім часом дуже популярним і
найширше затребуваним є система контролю версій Git.

Git — це розподілена система контролю версій. Це означає, що немає
“центральної” версії репозиторію з вашим проектом, натомість будь-який
репозиторій на будь-якому компі чи сервері може бути “головним”, “основним”,
тощо. Але фокус ось у чому: те, що Git це дозволяє — не означає, що усі так
роблять. Тому більшість проектів мають типу “головну” версію на
GitHub/GitLab/деінде, і усі розробники з нею синхронізуються. Бо так зручніше.
Втім, розподілений варіант розробки теж має місце — наприклад, при розробці
ядра Linux, але про складні ієрархічні процеси там ми зараз говорити не будемо.

Узагалі, у Git дуже потужна архітектура, яка дозволяє безліч різноманітних
використань. Най рядок про блокчейн звучить трохи пафосно, але по-суті так і є.
Кожен коміт посилається на попередній і його хеш залежить від хешу попереднього
коміту. Коміт — це фіксація стану файлів проекту, іншими словами — версія
проекту

Як я вже казав, Git дозволяє різноманітні способи використання, в т.ч. включати
один проект як частину іншого на рівні репозиторію. Існує чимало інструментів,
які використовують Git і дозволяють з ним працювати простіше і зручніше. Але
поки що ми зупинимося на найпростішому сценарії використання

Ми зупинимося на простому сценарії, де використовуватимемо git для того, щоб
трекати історію в одному проекті і мати змогу повернутися до попередньої. Те,
що показую я зараз я виконую в командному рядку. На windows є git bash, який
відкриє вам аналогічний командний рядок і ці ж команди вам будуть доступні.

Ви вільні використовувати будь-який інструментарій для роботи з Git. Хочете —
користуйтеся gitkraken чи вбудованим у вашу IDE функціоналом. Хочете — будь-чим
іншим, але майте на увазі, що коли користуєтеся красивою магією з кнопочками
було б круто розуміти, що ці кнопочки роблять. Тому рекомендую хоча б разово
розібратися як працювати з командним рядком, просто для розуміння.
