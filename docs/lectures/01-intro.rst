=====
Вступ
=====


Індустрія IT — величезна, і куди саме вас занесе доля — я не знаю, і не можу
знати. Що ви використовуватимете? Як працюватимете? Хтозна. Цей курс багато
позичив із курсу про тестування програмного забезпечення, а той у свою чергу —
базується на власному досвіді, так і на досвіді інших. За основу для матеріалу
там вибрали книгу `Software Engineering @ Google видавництва O’Reilly
<https://abseil.io/resources/swe-book>`_. Там описані підходи і практики, які
працюють для багатьох команд в Google. Також до них примішано і власний досвід.
Але те, що спрацювало для інших зовсім не обов’язково працюватиме для вас у
вашій компанії, на це впливає чимало різних факторів. Тому не треба сприймати
усе в цьому курсі як нерушиму істину. Це не догми і не заповіді. Правила, про
які я розповідаю, можна, а інколи і просто необхідно порушувати. Головне —
завжди пам’ятати про здоровий ґлузд і розуміти, що і навіщо ви робите.

Якщо я не помиляюся, ваша спеціальність називається саме так: “Інженерія
програмного забезпечення”. Багато хто із вас та й інших студентів, в т.ч. вже
випускників, коли їх питають чим ви займаєтеся, відповідають — програмуванням.
Як ви думаєте, це одне й те саме? Чи є відмінність між програмною інженерією
(software engineering) та програмуванням (programming)?

Імениті дядьки, на кшталт `Роба Пайка
<https://en.wikipedia.org/wiki/Rob_Pike>`_ чи `Тайтуса Вінтерса
<https://twitter.com/TitusWinters>`_, чи навіть того рандомного чєла в
коментарях на stackoverflow, визначають програмну інженерію як програмування,
що йде крізь час. Часто — ще й крізь декілька людей. Яким же
чином час може впливати на ваш проект?

- Ви запилили лабку, запустили її на своєму компі, щоб показати викладачу і
  забули про неї. Це **програмування**
- Коли ви пилите проект, у вас на компі накрився диск, даним на ньому прийшли
  гайки, але ви купили новий і трагедії не відбулося — круто, це **інженерія**

Також, мова йде про інженерію:

- Коли прилетіло оновлення ОС, а ваше рішення як працювало раніше, так і працює
- Коли вийшла нова версія бібліотеки і ви змогли швидко оновити цю бібліотеку
  не зламавши при цьому програму
- Коли вийшла нова версія мови програмування, підтримка старої закінчена, а ваш
  проект все ще компілюється
- Коли ви можете внести зміни у код так, щоб нічого іншого не зламати
- Коли до вас на проект приєдналися ваші колеги
- Коли ви звільнилися, а інші продовжують займатися вашим проектом


Якщо вам важливо, щоб ваш проект працював і в майбутньому, незважаючи на купу
різних факторів — ви займаєтеся програмною інженерією. Якщо вам треба запустити
код раз чи два і викинути — це програмування. Але скільки може жити ваш код?
Протягом якого часу його будуть використовувати? Хвилини? Дні? Місяці? Давайте
спробуємо навести приклади для кожної з категорій:


.. code::

   ----------------------------------->
   M   H       D   W      M   Y   D    time, t
   i   o       a   e      o   e   e
   n   u       y   e      n   a   c
   u   r       s   k      t   r   a
   t   s           s      h   s   d
   e                      s       e
   s                              s

не більше **декількох хвилин** буде використовуватися цикл в командному рядку для
одноманітної обробки десятків файлів (наприклад, щоб конвертувати з десяток
відео з одного формату в інший).

**Дні-тижні** — на жаль, більшість проектів, які ви робите в університеті. Лабки
будуть здані і забуті. В кращому випадку передані наступним поколінням за
шоколадку, які так само здадуть, забудуть, передадуть. Можливо пару місяців ви
працюватимете над дипломом чи курсачом.

**Місяці** — більшість стартапів. Мета стартапу — протриматися до наступного раунду
фінансування, нарощуючи фічі і затягуючи клієнтів. Небагатьом вдається вижити,
і вони закриваються. Також сюди можна віднести якісь AB-тести або
Proof-of-Concept в компаніях, які живуть стільки, скільки необхідно для
перевірки тієї чи іншої гіпотези.

**Роками та десятиліттями** живуть великі і успішні продукти. Власники цих
продуктів не збираються їх закривати. Спільнота Linux не збирається припиняти
розробку ядра. Можливо, колись воно загнеться, але поки усе йде добре — проекти
мають діяти так, ніби їхній код існуватиме вічно.


Написання коду з коротким терміном життя — це задачі програмування. Тут вимоги
не міняються, рефакторинг не потрібен, зате важлива швидкість.

Чи правіше на цій шкалі знаходиться проект, тим більше треба думати про вплив
часу та адаптацію до змін. Вам треба думати про те, як побудуєте командну
роботу, як оновлюватися, тощо…

.. code::

   Programming           Software Engineering
   (It works)            (It is maintainable)
   ----------------------------------->
   M   H       D   W      M   Y   D    time, t
   i   o       a   e      o   e   e
   n   u       y   e      n   a   c
   u   r       s   k      t   r   a
   t   s           s      h   s   d
   e                      s       e
   s                              s


То що ж краще:

    Код, який працює ідеально без помилок, але усі бояться його зламати

чи

    Код з багами, але в який може легко вносити зміни і виправлення навіть
    студент-першокурсник?

На перший погляд, здається, що ідеально робочий код без помилок — краще. З
іншого боку — навпаки, краще коли код підтримуваний. Насправді ж, **it depends**.

Якщо у вас за 5 хв здача екзамену, від чого залежить будете ви на стипендії чи
ні — код, що вирішує задачу краще. Аналогічно, коли цей код займає 2-3 рядка і
його можна з легкістю переписати. Але якщо хочете будувати на програмі бізнес
-— готуйтеся підтримувати її протягом років і адаптувати проект до змін.

Зміни так чи інакше з часом настигнуть вас і ваш проєкт. Навіть якщо ви все
зробили ідеально, світ довкола міняється. Ще не так давно пейджер був вершиною
технологій зв’язку, а зараз набувають поширення смартфони зі складним екраном.
А що буде через декілька років — складно й уявити. Міняється світ, змінюються
люди, змінюються способи взаємодії і вимоги. І в такому русі практично
неможливо просто написати програму і надіятися, що вона працюватиме в такому ж
вигляді завжди. Будуть нові фічі, переробка інтерфейсу, тощо.

.. code::

   Analysis
      |
      +---- Requirement
           specification
                |
                +-------- Design
                             |
                             +---- Development
                                        |
                                        +------ Testing
                                                  and
                                              integration
                                                    |
                                                    +------- Deployment

Раніше люди намагалися заздалегідь розрахувати усе, спершу гарно все
спланувати, спроектувати а потім ґрунтовно сісти і зробити добре, після чого
добряче перевірити, і коли вже все точно буде ідеально — випускати у світ. Цей
підхід, якщо його намалювати візуально нагадує каскадний водоспад. І він
працював, більш того, в деяких специфічних випадках працює і зараз. Проте для
багатьох проектів час був невблаганний — внаслідок змін в оточуючому світі
проекти ставали нікому не потрібними і застарілими вже на етапі розробки. І ця
неповоротка махіна давала збій. Тож люди прийшли до того, щоб їсти пиріг
частинами. Процес планування і розробки проекту став ітеративним. Замість
планувати усе і одразу команда зосереджувалася на невеликому наборі фіч, які
актуальні на поточному етапі розвитку продукту. Швидко робила їх і потім знову
здійснювала аналіз, виявляла нові вимоги і так далі по колу. Таким чином
людство прийшло до того, що адаптувало процеси до змін за допомогою “гнучких”
(agile) методологій.

.. code::
 
           Discover ----+            
      +-----------------|---------------> Discover ----+
     Test               v             +-----------------|----------------> ...
      ^   sprint #1   Design         Test               v
      |                 |             ^   sprint #2   Desi
      +--- Develop <----+             |                 |
                                      +--- Develop <----+


Але оскільки, як вже було сказано вище, ніщо не є універсальним рецептом, то ці
ж люди задекларували в своєму `маніфесті <https://agilemanifesto.org/>`_
наступне:

    Individuals and interactions > processes and tools
    Working software > comprehensive documentation
    Customer collaboration > contract negotiation
    Responding to change > following a plan

люди і взаємодія між ними важливіша за процеси та інструменти. Якщо процес чи
інструмент заважає ефективній взаємодії людей для досягнення мети — фтопку їх.
замість писати десяток томів документації краще зосередитися на тому, щоб софт
працював що переговори над деталями контракту важливі, але не настільки
важливі, як співпраця з клієнтом будь-який план можна відкинути, аби ефективно
реагувати на зміни.

В інженерній галузі також були створені різноманітні підходи і техніки
адаптації до змін. Ось декілька із них:

- Tests
- Version Control Systems
- Code review
- Consistency
- Continuous integration
- Static and dynamic code analysis tooling
- Small refactoring (microrefactoring)
- Big refactoring
- Dependency management
- Canarying
- A/B testing
